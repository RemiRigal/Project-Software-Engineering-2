1.	Introduction

1.1.	Purpose
The Integration Test Plan Document provides a dynamic technique to verify and validate the activities and software artifacts of a project.
Its aim is to find and show the presence of bug in the project. In this document is used systematic testing which uses the structure of the software artifacts and some information on the system's behavior.

1.2.	Scope
The scope of the project PowerEnjoy, which is a service based on mobile application, is to manage, design, build, and implement a service aimed at facilitating public transportation. 
The application provides to its target, the client, a way to research an electric car near a position, reserve it and pick it for a ride. At the end the application sends the ride's bill to the client. 
The PowerEnjoy application needs the client to be registered in its database before he can reserve a car, for security and payment reasons (credential information, driver license, and identity card).  
When the client logs in, the mobile application allows him to reserve a car around an address or his GPS position. Then it provides him details about his reservation on the main page.  
The application also allows the client to cancel his reservation, unlock the reserved car when he is near it, and access his account details to modify it. 
After the ride the application locks the car and sends an email to the client with the bill of the ride. The mobile application can moreover give discounts and charges in function of the client’s ride such as sharing the car or plug it in power grid station. 
The PowerEnjoy application is built in order to ensure an easy and clear reservation service as well as an effective data collecting and saving.  
This refers the PowerEnjoy application simplifies the customer’s uses, optimises the time to reserve a car and adjusts the price of the ride according to the driver.

1.3.	Definitions, Acronyms, Abbreviations
1.4.	Reference documents
1.5.	Used Tools

1.6.	Document structure
In the following parts of the document are described the main caracteristics of the integration testing plan. 
Integration Strategy
This section introduces the elements to be tested and how they will be integrated, describing moreover the other criterias related to the integration. 
Individual Steps and Test Description
This part describes the type of tests that will be used to verify that the elements integrated at each step perform as expected.
Tools and Test Equipment Required
In this section are presented all the tools and test equipments needed to accomplish the integration. 
Program Stubs and Test Data Required 
This part identifies the program stubs and special test data that are required for each integration step.
Finally the hours of work repartition follows this section.

2. Integration Strategy

2.1 Entry Criteria [Noëlie]
In this paragraph are presented the documents and unit tests that must have been delivered or done before proceeding the integration test.

The following documents are needed to ensure that the test process has visibility within the overall project and that the test tasks are started at the appropriate time :
The Requirement Analysis and Specifications Document to state the requirements of the system
The Design Document to understand the software architecture of the project

The following functions have to be unit tested with specific input to find the problems early and facilitate the changes of the them. 
Verify the connexion between :
The Database and the DriverManager, by making a unit test on the "verifyDriver(String email)" function and that it can be modify with a test on the "addCar(String id, String location, Int battery, Bool available)" function (linking the CarManager and the Database).
The Mobile Application and the Router, by testing the "verifyRegistrationUser(String[] data)" function the "verifyLogin(String email, Sting password)" function and the "displayMainPage()" one.
The ReservationController and the NotificationHelper, by checking the "sendSMS&MailConfirm()" function.
The Car and the CarManager, by testing the "unlockCar(Car car)" function (linking the CarManager to the Car)
The Router and the ReservationController/ResearchController/DriverController/LoginController with the functions "transfertRequest(args)" with the appropriate arguments.

From a components point of view, before testing the program should contains an amount of code for each one :
The Database has to be ready for an architectural point of view, it should lack only some data, so a total completion of 90% of the code
The DriverManager and LoginManager have to present the possibilities to register, login and reserve a car so a total completion of 70% of the code
The ResearchManager and ReservationManager have to be nearly achieved  so a total completion of 80% of the code
The RideManager and NotificationHelper are less critical and can be only  achieved partially  so a total completion of 50% of the code

Before delivering the product , all these components have to present a minimum of 95% of completion.
This list presents a completion priority that correspond to a critical order of the components, it can explain the following choices made to integrate the sub-systems during the tests.

2.2 Elements to be Integrated[Noëlie]
In this part are identified the components that have to be integrated to perform the testing plan of the system. 
Based on the Subsystem and Component View diagrams of the Design Document, the selected components are the following :
The RideManager														   /////////////////
The CarManager														     /////////////////
The ReservationController									   /////DESSIN/////
The ResearchController											 //////JOLI///////
The DriverController											   /////////////////
The LoginController											 /////////////////
The NotificationHelper (Manager)				   /////////////////

These ones have been choosen because they are the code modules that manage all the program. They are in charge of the requests transfer between each others or external items (NotificationHelper to the three Gateways)  to create the model.
The PowerEnjoy system is based on these interactions between these high-level components which represent the sub-systems of the program and hold a unique functionality (DriverManager : History, Account, Credentials, ReservationManager : Car, Ride).
According to the denpendencies between the components, some sets of sub-systems can be created to identify clearly the linked components to be integrated in the test. 
The Driver Systems composed of the DriverManager, the LoginManager and the NotificationHelper sub-systems
The  Car Systems composed of the CarManager, ResearchManager, ReservationManager, RideManager and NotificationHelper sub-systems

It can be noticed that the NotificationHelper takes part of both sub-systems set due to the dependencies of the ReservationManager and LoginManager to it.
Moreover this component links the PowerEnjoy system to another one in charge of the Mail/SMS/Push Gateways that already exist and don't have to be tested.
The other existing component that has to be take into account during the integration tests is the linker between the Database and the other components. This one manages the requests adressed to the Database, it is the Database Manager System.
These externals components represent the highest level subsystems and because they already have been tested will not be part of the integration tests.

Finally these are the components to be integrated group by set of sub-systems.
The arrows represent the dependency of each component to the others.



2.3 Integration Testing Strategy (approach) [rémi]
Describe the integration testing approach (top-­-down, bottom-­-up, functional groupings, etc.)  and the rationale for the choosing that approach. 

2.4 Sequence of Component/Function Integration
NOTE: The structure of this section may vary depending on the integration strategy you select in Section 2.3;  use the structure proposed below as a non mandatory guide
2.4.1 Software Integration Sequence. 
For each subsystem, identify the sequence in which the software components will be integrated within the subsystem; relate this sequence to any product features that are being built up.
2.4.2 Subsystem  Integration Sequence.
Identify the order in which subsystems will be integrated; if you have a single subsystem, 2.4.1 and 2.4.2 are to be merged in a single section. You can refer to Section 2.2 of the test plan example [1] as an example. 

2.5.	Item Pass/Fail Criteria [vianney]
2.6.	Environmental Needs  [vianney]
Simulation of the element that are external to the software:
Behavior test: what is happening in case of missing data or wrong data received/send
	Simulator of car behavior: simulate information exchanged between the car and the system
	Simulator of user behavior: simulate the behavior of the user through the application

Used before the beta test involving a sample of cars and users and 
for software components that are directly connected to them
Will also be used to populate the database

The data provided by the simulators should have the same form as the real ones

Early test involving few data and element will be run in a  private secure network
to prevent the access of external users and security breach

2.7.	Responsibilities [vianney]
List of manager for integration test:
	Network implementation 
	Security breach of system
	Simulators development
	System's general behavior
	System integration
	Unit testing

3.  Individual Steps and Test Description (Test case specifications + Test procedures)
For each step of the integration process above, describe the type of tests that will be used to verify that the elements integrated in this step perform as expected. Describe in general the expected results of the test set.
You may refer to Chapter 3 and Chapter 4 of the test plan example [1] as an  example of what we expect. (NOTE: This is not a detailed description of test protocols. Think of this as the test design phase. 
Specific protocols will be written to fulfill the goals of the tests in this section.)
3.1. Integration Test case I1
3.2. Test procedure TP1

4. Tools and Test Equipment Required
Identify all tools and test equipment needed to accomplish the integration.  Refer to the tools presented during the lectures. Explain why and how you are going to use them. Note that you may also use manual testing for some part. 
Consider manual testing as one of the possible tools you have available.
4.1. Tools
To perform all the tests on the several components of the PowerEnjoy system, it is necessary to use some appropriate testing tools. 
Concerning the unit testing that have to be done before the integration plan, the Mockito test tool will be used. These tests have to be fast and cover small tasks, by using mocking it is possible to abstract the dependencies and have predictable results to ensure that caracteristics.
Moreover the mocking permits to verify the interactions between items and provides a framework to do so. That's why the Mockito test tool wil also be use to test the business logic of the components which run in the JEE runtime environement.
Mockito will verify the interactions between the components by creating mocks, it will permit to test the results (data, exceptions and errors) but also to simulate external components like the Notification Gateways . 

Still in the purpose of testing the business logic, the Arquillian  testing tool will be used to check the interactions with the system according to the dependencies and the transaction controls. The tests will be performed against a Java container  to ensure that the components interactions are correctly happening.
Moreover, using test archive to isolate the classes and ressources it will be easier to focus on the classes/components to test. The Arquillian tool will be used in particular to monitor that the dependencies' injections are respected and to verify that the Database connections are well managed. 

Concerning the tests of the functional behavior and measure of the performance the Jmeter testing tool will be used. The purpose will be to simulate quite heavy load on the server to analyse its strength.
For instance some simulations will introduce a certain number of drivers that will try to login into the server at the same time, with then different requests to be achieved by the server.

For the concern of the mobile devices, ;;;
Finally some part of the integration testing plan require the use of manual testing to be performed efficiently. For instance the ..... parts need a manual testing operations. 

4.2. Test Equipment


5. Program Stubs and Test Data Required  
Based on the testing strategy and test design, identify any program stubs or special test data required for each integration step.
5.1. Program Stubs 

5.2. Test Data [Noëlie]
To perfom all the test that have been described in the whole document the following data are needed :

A list of unregistered drivers who can have valid or invalid personal information. This list will be used to test the DriverManager, the LoginManager and the NotificationHelper components. The set of data must contain drivers with the following problems :
Null object
No arguments 
Invalid driving license
Invalid email address 
Invalid mobile phone number 

A list of cars with valid and invalid caracteristics to test the CarManager and the RideManager components. This set of data has to contain cars with these problems:
Null object
No arguments
Invalid battery level
Invalid location (in the sea for instance)
Invalid number of places 

A list of researchs which will have valid or invalid fields. This list will be used to test the ResearchManager component. It must contains researchs with the following problems:
Null object
No arguments
Invalid adress location 
Invalid maximum distance

A list of reservations with valid and invalid caracteristics to test the ReservationManager component. This set of data has to contain reservations with these problems:
Null object
No arguments
Invalid car id
Invalid driver email

It is to notice that the safe areas don't have to be tested because they are pre-defined in the management system, which already exist and tested. 
  


6.	Hours of work
6.1.	Vianney Payelle
6.2.	Rémi Rigal
6.3.	Noëlie Ramuzat

